// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        v3.12.4
// source: api/signing.proto

package api

import (
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TokenVersion int32

const (
	// Body contains are bare ReplToken and must be decoded explicitly
	TokenVersion_BARE_REPL_TOKEN TokenVersion = 0
	// Body contains a GovalToken and can be interrogated about the type of its
	// own message
	TokenVersion_TYPE_AWARE_TOKEN TokenVersion = 1
)

// Enum value maps for TokenVersion.
var (
	TokenVersion_name = map[int32]string{
		0: "BARE_REPL_TOKEN",
		1: "TYPE_AWARE_TOKEN",
	}
	TokenVersion_value = map[string]int32{
		"BARE_REPL_TOKEN":  0,
		"TYPE_AWARE_TOKEN": 1,
	}
)

func (x TokenVersion) Enum() *TokenVersion {
	p := new(TokenVersion)
	*p = x
	return p
}

func (x TokenVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TokenVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_api_signing_proto_enumTypes[0].Descriptor()
}

func (TokenVersion) Type() protoreflect.EnumType {
	return &file_api_signing_proto_enumTypes[0]
}

func (x TokenVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TokenVersion.Descriptor instead.
func (TokenVersion) EnumDescriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{0}
}

type FlagClaim int32

const (
	// Cert has the authority to sign ReplToken messages that can be validated
	// by goval
	FlagClaim_MINT_GOVAL_TOKEN FlagClaim = 0
	// Cert has the authority to sign additional intermediate certs. (The claims
	// on intermediate certs signed by this cert are still enforced.)
	FlagClaim_SIGN_INTERMEDIATE_CERT FlagClaim = 1
	// Cert has the authority to sign GovalToken messages that can prove identity.
	FlagClaim_IDENTITY FlagClaim = 5
	// Cert has ability to mint Repl Identity tokens
	FlagClaim_RENEW_IDENTITY FlagClaim = 7
	// Cert has ability to mint Repl KV tokens
	FlagClaim_RENEW_KV FlagClaim = 8
	// Cert has the authority to sign GovalToken messages that authorizes the
	// bearer to use Ghostwriter.
	FlagClaim_GHOSTWRITER FlagClaim = 6
	// Cert has the authority to sign ReplToken messages that claim to be from
	// a deployment.
	FlagClaim_DEPLOYMENT FlagClaim = 10
	// Cert has the authority to sign ReplToken messages for any ReplID. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_REPLID FlagClaim = 2
	// Cert has the authority to sign ReplToken messages for any user. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_USER FlagClaim = 3
	// Cert has the authority to sign ReplToken messages for any cluster. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_CLUSTER FlagClaim = 4
	// Cert has the authority to sign ReplToken messages for any subcluster. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty and the
	// identity token contains a subcluster, the identity token will be rejected.
	FlagClaim_ANY_SUBCLUSTER FlagClaim = 9
)

// Enum value maps for FlagClaim.
var (
	FlagClaim_name = map[int32]string{
		0:  "MINT_GOVAL_TOKEN",
		1:  "SIGN_INTERMEDIATE_CERT",
		5:  "IDENTITY",
		7:  "RENEW_IDENTITY",
		8:  "RENEW_KV",
		6:  "GHOSTWRITER",
		10: "DEPLOYMENT",
		2:  "ANY_REPLID",
		3:  "ANY_USER",
		4:  "ANY_CLUSTER",
		9:  "ANY_SUBCLUSTER",
	}
	FlagClaim_value = map[string]int32{
		"MINT_GOVAL_TOKEN":       0,
		"SIGN_INTERMEDIATE_CERT": 1,
		"IDENTITY":               5,
		"RENEW_IDENTITY":         7,
		"RENEW_KV":               8,
		"GHOSTWRITER":            6,
		"DEPLOYMENT":             10,
		"ANY_REPLID":             2,
		"ANY_USER":               3,
		"ANY_CLUSTER":            4,
		"ANY_SUBCLUSTER":         9,
	}
)

func (x FlagClaim) Enum() *FlagClaim {
	p := new(FlagClaim)
	*p = x
	return p
}

func (x FlagClaim) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlagClaim) Descriptor() protoreflect.EnumDescriptor {
	return file_api_signing_proto_enumTypes[1].Descriptor()
}

func (FlagClaim) Type() protoreflect.EnumType {
	return &file_api_signing_proto_enumTypes[1]
}

func (x FlagClaim) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlagClaim.Descriptor instead.
func (FlagClaim) EnumDescriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{1}
}

// GovalSigningAuthority is information about a goval token, that can be used to
// validate it. It is stored in the footer of the PASETO.
type GovalSigningAuthority struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Cert:
	//
	//	*GovalSigningAuthority_KeyId
	//	*GovalSigningAuthority_SignedCert
	Cert isGovalSigningAuthority_Cert `protobuf_oneof:"cert"`
	// An enum detailing how the body of the PASETO this is a footer of should
	// be decoded
	Version TokenVersion `protobuf:"varint,3,opt,name=version,proto3,enum=api.TokenVersion" json:"version,omitempty"`
	// A string containing the issuer of a token. This is used to track who is
	// sending tokens with a particular key id, so that we can rotate safely.
	Issuer string `protobuf:"bytes,4,opt,name=issuer,proto3" json:"issuer,omitempty"`
}

func (x *GovalSigningAuthority) Reset() {
	*x = GovalSigningAuthority{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GovalSigningAuthority) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GovalSigningAuthority) ProtoMessage() {}

func (x *GovalSigningAuthority) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GovalSigningAuthority.ProtoReflect.Descriptor instead.
func (*GovalSigningAuthority) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{0}
}

func (m *GovalSigningAuthority) GetCert() isGovalSigningAuthority_Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (x *GovalSigningAuthority) GetKeyId() string {
	if x, ok := x.GetCert().(*GovalSigningAuthority_KeyId); ok {
		return x.KeyId
	}
	return ""
}

func (x *GovalSigningAuthority) GetSignedCert() string {
	if x, ok := x.GetCert().(*GovalSigningAuthority_SignedCert); ok {
		return x.SignedCert
	}
	return ""
}

func (x *GovalSigningAuthority) GetVersion() TokenVersion {
	if x != nil {
		return x.Version
	}
	return TokenVersion_BARE_REPL_TOKEN
}

func (x *GovalSigningAuthority) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

type isGovalSigningAuthority_Cert interface {
	isGovalSigningAuthority_Cert()
}

type GovalSigningAuthority_KeyId struct {
	// The ID of the root public key that was used to sign the token.
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3,oneof"`
}

type GovalSigningAuthority_SignedCert struct {
	// A signed PASETO with a GovalCert in the body and the
	// GovalSigningAuthority used to sign the body in the footer.
	SignedCert string `protobuf:"bytes,2,opt,name=signed_cert,json=signedCert,proto3,oneof"`
}

func (*GovalSigningAuthority_KeyId) isGovalSigningAuthority_Cert() {}

func (*GovalSigningAuthority_SignedCert) isGovalSigningAuthority_Cert() {}

// Claims are actions that a cert is allowed to do. Claims can be repeated (e.g.
// to allow a cert to apply to multiple replids or users).
//
// Claims should be enforced on certificates by ensuring that certificates
// are signed by a certificate that has a superset of claims.
//
// When a cert is used to sign a message, it is the responsibility of the
// service validating the message to ensure that any requests in the message are
// backed up by claims in the certificate. Claims in a single certificate should
// be interpreted as a union (e.g. if replid and user is set, the token may
// apply to any repls owned by the user, or any repls in replid, regardless of
// the owner).
type CertificateClaim struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Claim:
	//
	//	*CertificateClaim_Replid
	//	*CertificateClaim_User
	//	*CertificateClaim_Cluster
	//	*CertificateClaim_Subcluster
	//	*CertificateClaim_Flag
	Claim isCertificateClaim_Claim `protobuf_oneof:"claim"`
}

func (x *CertificateClaim) Reset() {
	*x = CertificateClaim{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CertificateClaim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateClaim) ProtoMessage() {}

func (x *CertificateClaim) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateClaim.ProtoReflect.Descriptor instead.
func (*CertificateClaim) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{1}
}

func (m *CertificateClaim) GetClaim() isCertificateClaim_Claim {
	if m != nil {
		return m.Claim
	}
	return nil
}

func (x *CertificateClaim) GetReplid() string {
	if x, ok := x.GetClaim().(*CertificateClaim_Replid); ok {
		return x.Replid
	}
	return ""
}

func (x *CertificateClaim) GetUser() string {
	if x, ok := x.GetClaim().(*CertificateClaim_User); ok {
		return x.User
	}
	return ""
}

func (x *CertificateClaim) GetCluster() string {
	if x, ok := x.GetClaim().(*CertificateClaim_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (x *CertificateClaim) GetSubcluster() string {
	if x, ok := x.GetClaim().(*CertificateClaim_Subcluster); ok {
		return x.Subcluster
	}
	return ""
}

func (x *CertificateClaim) GetFlag() FlagClaim {
	if x, ok := x.GetClaim().(*CertificateClaim_Flag); ok {
		return x.Flag
	}
	return FlagClaim_MINT_GOVAL_TOKEN
}

type isCertificateClaim_Claim interface {
	isCertificateClaim_Claim()
}

type CertificateClaim_Replid struct {
	// This cert has the authority to sign messages on behalf of a replid
	Replid string `protobuf:"bytes,1,opt,name=replid,proto3,oneof"`
}

type CertificateClaim_User struct {
	// This cert has the authority to sign messages on behalf of a user
	User string `protobuf:"bytes,2,opt,name=user,proto3,oneof"`
}

type CertificateClaim_Cluster struct {
	// This cert has the authority to sign messages in a certain cluster
	Cluster string `protobuf:"bytes,4,opt,name=cluster,proto3,oneof"`
}

type CertificateClaim_Subcluster struct {
	// This cert has the authority to sign messages in a certain cluster
	Subcluster string `protobuf:"bytes,5,opt,name=subcluster,proto3,oneof"`
}

type CertificateClaim_Flag struct {
	// This cert has the authority to perform an action as described in
	// FlagClaim
	Flag FlagClaim `protobuf:"varint,3,opt,name=flag,proto3,enum=api.FlagClaim,oneof"`
}

func (*CertificateClaim_Replid) isCertificateClaim_Claim() {}

func (*CertificateClaim_User) isCertificateClaim_Claim() {}

func (*CertificateClaim_Cluster) isCertificateClaim_Claim() {}

func (*CertificateClaim_Subcluster) isCertificateClaim_Claim() {}

func (*CertificateClaim_Flag) isCertificateClaim_Claim() {}

// GovalCert provides a mechanism of establishing a chain of trust without
// requiring a single private key to be duplciated to all services that send
// messages. The processes of generating intermediate certs is as follows:
//   - A PASETO `v2.public` root keypair is generated and added to GSM with an
//     arbitrary key id.
//   - The root public key id is encoded in a GovalSigningAuthority
//   - An intermediate PASETO `v2.public` keypair is generated
//   - The intermediate public key is encoded in a GovalCert, along with
//     information about the lifetime and claims of that cert.
//   - The GovalCert is encoded in the body of a PASETO and signed with the root
//     private key. The root signing authority is inserted into the footer of the
//     PASETO to use for validation.
//   - This signed PASETO is encoded in another GovalSigningAuthority and appended
//     as the footer of PASETOs signed by the intermediate private key.
//
// Additional intermediate certs can be generated and signed by private key and
// signing authority of the previous cert.
//
// When validating a chain of certs, the footer of each wrapped PASETO is
// recursed until reaching a root key id. The body of that PASETO is
// validated with the root public key. The body is decoded into a GovalCert,
// its lifetime is checked, and the public key is pulled out and used to
// validate the next PASETO, continuing back up the chain. At each step along
// the chain (except for the root), the claims of a certificate must be verified
// to be a subset of the claims of the certificate signing it.
type GovalCert struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Issue timestamp. Equivalent to JWT's "iat" (Issued At) claim.  Tokens with
	// no `iat` field will be treated as if they had been issed at the UNIX epoch
	// (1970-01-01T00:00:00Z).
	Iat *timestamp.Timestamp `protobuf:"bytes,1,opt,name=iat,proto3" json:"iat,omitempty"`
	// Expiration timestamp. Equivalent to JWT's "exp" (Expiration Time) Claim.
	// If unset, will default to one hour after `iat`.
	Exp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=exp,proto3" json:"exp,omitempty"`
	// A list of claims this cert can authorize
	Claims []*CertificateClaim `protobuf:"bytes,3,rep,name=claims,proto3" json:"claims,omitempty"`
	// The PASETO `v2.public` (Ed25519) public key authorized to sign requests in
	// this scope. Must be encoded in either PASERK SID or a PEM PUBLIC KEY
	// block.  (This key is usally generated in nodejs, and nodejs does not
	// provide an interface to get the raw key bytes)
	PublicKey string `protobuf:"bytes,4,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
}

func (x *GovalCert) Reset() {
	*x = GovalCert{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GovalCert) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GovalCert) ProtoMessage() {}

func (x *GovalCert) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GovalCert.ProtoReflect.Descriptor instead.
func (*GovalCert) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{2}
}

func (x *GovalCert) GetIat() *timestamp.Timestamp {
	if x != nil {
		return x.Iat
	}
	return nil
}

func (x *GovalCert) GetExp() *timestamp.Timestamp {
	if x != nil {
		return x.Exp
	}
	return nil
}

func (x *GovalCert) GetClaims() []*CertificateClaim {
	if x != nil {
		return x.Claims
	}
	return nil
}

func (x *GovalCert) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

// A GovalToken should be the body of any PASETO we send
type GovalToken struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Issue timestamp. Equivalent to JWT's "iat" (Issued At) claim.  Tokens with
	// no `iat` field will be treated as if they had been issed at the UNIX epoch
	// (1970-01-01T00:00:00Z).
	Iat *timestamp.Timestamp `protobuf:"bytes,1,opt,name=iat,proto3" json:"iat,omitempty"`
	// Expiration timestamp. Equivalent to JWT's "exp" (Expiration Time) Claim.
	// If unset, will default to one hour after `iat`.
	Exp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=exp,proto3" json:"exp,omitempty"`
	// Tokens are only allowed to act for a single repl, replid is the repl that
	// this token is authorized for. The validator must check that the replid of
	// this token agrees with the claims in any of the certs signing it.
	Replid string `protobuf:"bytes,3,opt,name=replid,proto3" json:"replid,omitempty"`
	// The token body, all future tokens should rely on the information in
	// GovalToken to establish basic validity, and should only add additional
	// fields. ReplToken has its own iat, exp, and replid for legacy reasons.
	//
	// Types that are assignable to Token:
	//
	//	*GovalToken_ReplToken
	//	*GovalToken_ReplIdentity
	Token isGovalToken_Token `protobuf_oneof:"Token"`
}

func (x *GovalToken) Reset() {
	*x = GovalToken{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GovalToken) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GovalToken) ProtoMessage() {}

func (x *GovalToken) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GovalToken.ProtoReflect.Descriptor instead.
func (*GovalToken) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{3}
}

func (x *GovalToken) GetIat() *timestamp.Timestamp {
	if x != nil {
		return x.Iat
	}
	return nil
}

func (x *GovalToken) GetExp() *timestamp.Timestamp {
	if x != nil {
		return x.Exp
	}
	return nil
}

func (x *GovalToken) GetReplid() string {
	if x != nil {
		return x.Replid
	}
	return ""
}

func (m *GovalToken) GetToken() isGovalToken_Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (x *GovalToken) GetReplToken() *ReplToken {
	if x, ok := x.GetToken().(*GovalToken_ReplToken); ok {
		return x.ReplToken
	}
	return nil
}

func (x *GovalToken) GetReplIdentity() *GovalReplIdentity {
	if x, ok := x.GetToken().(*GovalToken_ReplIdentity); ok {
		return x.ReplIdentity
	}
	return nil
}

type isGovalToken_Token interface {
	isGovalToken_Token()
}

type GovalToken_ReplToken struct {
	// This token is used to authorize a request to create a repl in goval
	ReplToken *ReplToken `protobuf:"bytes,4,opt,name=repl_token,json=replToken,proto3,oneof"`
}

type GovalToken_ReplIdentity struct {
	// This token is used to prove a Repl's identity.
	ReplIdentity *GovalReplIdentity `protobuf:"bytes,5,opt,name=repl_identity,json=replIdentity,proto3,oneof"`
}

func (*GovalToken_ReplToken) isGovalToken_Token() {}

func (*GovalToken_ReplIdentity) isGovalToken_Token() {}

// A GovalReplIdentity is used in identity PASETO tokens which are used for
// authentication between repls.
type GovalReplIdentity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// This identity has this Repl ID
	Replid string `protobuf:"bytes,1,opt,name=replid,proto3" json:"replid,omitempty"`
	// This identity is in the context of this user
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// This repl has this slug
	Slug string `protobuf:"bytes,3,opt,name=slug,proto3" json:"slug,omitempty"`
	// If set, this token can only be consumed by this a Repl with this Repl ID.
	// Equivalent to JWT's "aud" (Audience) claim.
	Aud string `protobuf:"bytes,4,opt,name=aud,proto3" json:"aud,omitempty"`
	// If true, this token is generated in an ephemeral environment (such as
	// a guest fork). Systems can use this to potentially reject ephemeral tokens
	// if that makes sense for their API.
	Ephemeral bool `protobuf:"varint,5,opt,name=ephemeral,proto3" json:"ephemeral,omitempty"`
	// This identity is forked from this Repl ID.
	// This is set for "guest forks", where server(s) might need to know the
	// original repl's ID despite the running environment being a fork.
	OriginReplid string `protobuf:"bytes,6,opt,name=originReplid,proto3" json:"originReplid,omitempty"`
	// same as the `user` field, but it's the ID instead of the username
	UserId int64 `protobuf:"varint,7,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// If this is a build repl for a hosting deployment, include extra
	// information about the specs of the build
	BuildInfo *BuildInfo `protobuf:"bytes,8,opt,name=build_info,json=buildInfo,proto3" json:"build_info,omitempty"`
	// A boolean indicating if the owner of the repl is a team.
	IsTeam bool `protobuf:"varint,9,opt,name=is_team,json=isTeam,proto3" json:"is_team,omitempty"`
	// A list of roles for the user who owns the repl.
	Roles []string `protobuf:"bytes,10,rep,name=roles,proto3" json:"roles,omitempty"`
	// Runtime information about the Repl.
	//
	// Types that are assignable to Runtime:
	//
	//	*GovalReplIdentity_Interactive
	//	*GovalReplIdentity_Deployment
	Runtime isGovalReplIdentity_Runtime `protobuf_oneof:"runtime"`
}

func (x *GovalReplIdentity) Reset() {
	*x = GovalReplIdentity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GovalReplIdentity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GovalReplIdentity) ProtoMessage() {}

func (x *GovalReplIdentity) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GovalReplIdentity.ProtoReflect.Descriptor instead.
func (*GovalReplIdentity) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{4}
}

func (x *GovalReplIdentity) GetReplid() string {
	if x != nil {
		return x.Replid
	}
	return ""
}

func (x *GovalReplIdentity) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *GovalReplIdentity) GetSlug() string {
	if x != nil {
		return x.Slug
	}
	return ""
}

func (x *GovalReplIdentity) GetAud() string {
	if x != nil {
		return x.Aud
	}
	return ""
}

func (x *GovalReplIdentity) GetEphemeral() bool {
	if x != nil {
		return x.Ephemeral
	}
	return false
}

func (x *GovalReplIdentity) GetOriginReplid() string {
	if x != nil {
		return x.OriginReplid
	}
	return ""
}

func (x *GovalReplIdentity) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *GovalReplIdentity) GetBuildInfo() *BuildInfo {
	if x != nil {
		return x.BuildInfo
	}
	return nil
}

func (x *GovalReplIdentity) GetIsTeam() bool {
	if x != nil {
		return x.IsTeam
	}
	return false
}

func (x *GovalReplIdentity) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (m *GovalReplIdentity) GetRuntime() isGovalReplIdentity_Runtime {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (x *GovalReplIdentity) GetInteractive() *ReplRuntimeInteractive {
	if x, ok := x.GetRuntime().(*GovalReplIdentity_Interactive); ok {
		return x.Interactive
	}
	return nil
}

func (x *GovalReplIdentity) GetDeployment() *ReplRuntimeDeployment {
	if x, ok := x.GetRuntime().(*GovalReplIdentity_Deployment); ok {
		return x.Deployment
	}
	return nil
}

type isGovalReplIdentity_Runtime interface {
	isGovalReplIdentity_Runtime()
}

type GovalReplIdentity_Interactive struct {
	// This is set if the Repl is running interactively. This is not set when
	// the Repl is running in hosting.
	Interactive *ReplRuntimeInteractive `protobuf:"bytes,11,opt,name=interactive,proto3,oneof"`
}

type GovalReplIdentity_Deployment struct {
	// This is set if the Repl is running in a Deployment.
	Deployment *ReplRuntimeDeployment `protobuf:"bytes,12,opt,name=deployment,proto3,oneof"`
}

func (*GovalReplIdentity_Interactive) isGovalReplIdentity_Runtime() {}

func (*GovalReplIdentity_Deployment) isGovalReplIdentity_Runtime() {}

// BuildInfo includes information about which deployment this repl is allowed to
// create or update.
type BuildInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ID is a unique identitifier for the deployment that this builder repl is
	// allowed to push to.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// URL is the replit.app URL that will be used for the deployment.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Build ID is a unique identifier for this particular deployment build
	BuildId string `protobuf:"bytes,3,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Tier refers to the GCE machine tier that will be used for the build
	MachineTier string `protobuf:"bytes,4,opt,name=machine_tier,json=machineTier,proto3" json:"machine_tier,omitempty"`
}

func (x *BuildInfo) Reset() {
	*x = BuildInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BuildInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildInfo) ProtoMessage() {}

func (x *BuildInfo) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildInfo.ProtoReflect.Descriptor instead.
func (*BuildInfo) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{5}
}

func (x *BuildInfo) GetDeploymentId() string {
	if x != nil {
		return x.DeploymentId
	}
	return ""
}

func (x *BuildInfo) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *BuildInfo) GetBuildId() string {
	if x != nil {
		return x.BuildId
	}
	return ""
}

func (x *BuildInfo) GetMachineTier() string {
	if x != nil {
		return x.MachineTier
	}
	return ""
}

type ReplRuntimeInteractive struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The cluster in which this Repl is running.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// The subcluster in which this Repl is running.
	Subcluster string `protobuf:"bytes,2,opt,name=subcluster,proto3" json:"subcluster,omitempty"`
}

func (x *ReplRuntimeInteractive) Reset() {
	*x = ReplRuntimeInteractive{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReplRuntimeInteractive) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplRuntimeInteractive) ProtoMessage() {}

func (x *ReplRuntimeInteractive) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplRuntimeInteractive.ProtoReflect.Descriptor instead.
func (*ReplRuntimeInteractive) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{6}
}

func (x *ReplRuntimeInteractive) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *ReplRuntimeInteractive) GetSubcluster() string {
	if x != nil {
		return x.Subcluster
	}
	return ""
}

type ReplRuntimeDeployment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ReplRuntimeDeployment) Reset() {
	*x = ReplRuntimeDeployment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_signing_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReplRuntimeDeployment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplRuntimeDeployment) ProtoMessage() {}

func (x *ReplRuntimeDeployment) ProtoReflect() protoreflect.Message {
	mi := &file_api_signing_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplRuntimeDeployment.ProtoReflect.Descriptor instead.
func (*ReplRuntimeDeployment) Descriptor() ([]byte, []int) {
	return file_api_signing_proto_rawDescGZIP(), []int{7}
}

var File_api_signing_proto protoreflect.FileDescriptor

var file_api_signing_proto_rawDesc = []byte{
	0x0a, 0x11, 0x61, 0x70, 0x69, 0x2f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x03, 0x61, 0x70, 0x69, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x10, 0x61, 0x70, 0x69, 0x2f, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa0, 0x01, 0x0a, 0x15,
	0x47, 0x6f, 0x76, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x75, 0x74, 0x68,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x17, 0x0a, 0x06, 0x6b, 0x65, 0x79, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x6b, 0x65, 0x79, 0x49, 0x64, 0x12, 0x21,
	0x0a, 0x0b, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0a, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x43, 0x65, 0x72,
	0x74, 0x12, 0x2b, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x56, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x16,
	0x0a, 0x06, 0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x69, 0x73, 0x73, 0x75, 0x65, 0x72, 0x42, 0x06, 0x0a, 0x04, 0x63, 0x65, 0x72, 0x74, 0x22, 0xaf,
	0x01, 0x0a, 0x10, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6c,
	0x61, 0x69, 0x6d, 0x12, 0x18, 0x0a, 0x06, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x06, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x12, 0x14, 0x0a,
	0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x75,
	0x73, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x07, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x07, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x12,
	0x20, 0x0a, 0x0a, 0x73, 0x75, 0x62, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0a, 0x73, 0x75, 0x62, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65,
	0x72, 0x12, 0x24, 0x0a, 0x04, 0x66, 0x6c, 0x61, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x0e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x46, 0x6c, 0x61, 0x67, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x48,
	0x00, 0x52, 0x04, 0x66, 0x6c, 0x61, 0x67, 0x42, 0x07, 0x0a, 0x05, 0x63, 0x6c, 0x61, 0x69, 0x6d,
	0x22, 0xb4, 0x01, 0x0a, 0x09, 0x47, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x65, 0x72, 0x74, 0x12, 0x2c,
	0x0a, 0x03, 0x69, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x03, 0x69, 0x61, 0x74, 0x12, 0x2c, 0x0a, 0x03,
	0x65, 0x78, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x03, 0x65, 0x78, 0x70, 0x12, 0x2d, 0x0a, 0x06, 0x63, 0x6c,
	0x61, 0x69, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6c, 0x61, 0x69,
	0x6d, 0x52, 0x06, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x70, 0x75, 0x62,
	0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x70, 0x75,
	0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x22, 0xf9, 0x01, 0x0a, 0x0a, 0x47, 0x6f, 0x76, 0x61,
	0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x2c, 0x0a, 0x03, 0x69, 0x61, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
	0x03, 0x69, 0x61, 0x74, 0x12, 0x2c, 0x0a, 0x03, 0x65, 0x78, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x03, 0x65,
	0x78, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x12, 0x2f, 0x0a, 0x0a, 0x72, 0x65,
	0x70, 0x6c, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x48, 0x00,
	0x52, 0x09, 0x72, 0x65, 0x70, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x3d, 0x0a, 0x0d, 0x72,
	0x65, 0x70, 0x6c, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x16, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x6f, 0x76, 0x61, 0x6c, 0x52, 0x65,
	0x70, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x65,
	0x70, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x42, 0x07, 0x0a, 0x05, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x22, 0xa8, 0x03, 0x0a, 0x11, 0x47, 0x6f, 0x76, 0x61, 0x6c, 0x52, 0x65, 0x70,
	0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x70,
	0x6c, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x70, 0x6c, 0x69,
	0x64, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x6c, 0x75, 0x67, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x6c, 0x75, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x75, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x61, 0x75, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x65,
	0x70, 0x68, 0x65, 0x6d, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09,
	0x65, 0x70, 0x68, 0x65, 0x6d, 0x65, 0x72, 0x61, 0x6c, 0x12, 0x22, 0x0a, 0x0c, 0x6f, 0x72, 0x69,
	0x67, 0x69, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x12, 0x17, 0x0a,
	0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06,
	0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x2d, 0x0a, 0x0a, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x5f,
	0x69, 0x6e, 0x66, 0x6f, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x09, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x17, 0x0a, 0x07, 0x69, 0x73, 0x5f, 0x74, 0x65, 0x61, 0x6d,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x69, 0x73, 0x54, 0x65, 0x61, 0x6d, 0x12, 0x14,
	0x0a, 0x05, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x72,
	0x6f, 0x6c, 0x65, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x52, 0x65, 0x70, 0x6c, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x48, 0x00, 0x52, 0x0b, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x61,
	0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x3c, 0x0a, 0x0a, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d,
	0x65, 0x6e, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x52, 0x65, 0x70, 0x6c, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x44, 0x65, 0x70, 0x6c, 0x6f,
	0x79, 0x6d, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d,
	0x65, 0x6e, 0x74, 0x42, 0x09, 0x0a, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x22, 0x80,
	0x01, 0x0a, 0x09, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x23, 0x0a, 0x0d,
	0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49,
	0x64, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x75, 0x72, 0x6c, 0x12, 0x19, 0x0a, 0x08, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x5f, 0x69, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x64, 0x12, 0x21,
	0x0a, 0x0c, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x74, 0x69, 0x65, 0x72, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x54, 0x69, 0x65,
	0x72, 0x22, 0x52, 0x0a, 0x16, 0x52, 0x65, 0x70, 0x6c, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65,
	0x49, 0x6e, 0x74, 0x65, 0x72, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x63,
	0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6c,
	0x75, 0x73, 0x74, 0x65, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x75, 0x62, 0x63, 0x6c, 0x75, 0x73,
	0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x75, 0x62, 0x63, 0x6c,
	0x75, 0x73, 0x74, 0x65, 0x72, 0x22, 0x17, 0x0a, 0x15, 0x52, 0x65, 0x70, 0x6c, 0x52, 0x75, 0x6e,
	0x74, 0x69, 0x6d, 0x65, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2a, 0x39,
	0x0a, 0x0c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x13,
	0x0a, 0x0f, 0x42, 0x41, 0x52, 0x45, 0x5f, 0x52, 0x45, 0x50, 0x4c, 0x5f, 0x54, 0x4f, 0x4b, 0x45,
	0x4e, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x57, 0x41, 0x52,
	0x45, 0x5f, 0x54, 0x4f, 0x4b, 0x45, 0x4e, 0x10, 0x01, 0x2a, 0xd1, 0x01, 0x0a, 0x09, 0x46, 0x6c,
	0x61, 0x67, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x49, 0x4e, 0x54, 0x5f,
	0x47, 0x4f, 0x56, 0x41, 0x4c, 0x5f, 0x54, 0x4f, 0x4b, 0x45, 0x4e, 0x10, 0x00, 0x12, 0x1a, 0x0a,
	0x16, 0x53, 0x49, 0x47, 0x4e, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4d, 0x45, 0x44, 0x49, 0x41,
	0x54, 0x45, 0x5f, 0x43, 0x45, 0x52, 0x54, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x44, 0x45,
	0x4e, 0x54, 0x49, 0x54, 0x59, 0x10, 0x05, 0x12, 0x12, 0x0a, 0x0e, 0x52, 0x45, 0x4e, 0x45, 0x57,
	0x5f, 0x49, 0x44, 0x45, 0x4e, 0x54, 0x49, 0x54, 0x59, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x52,
	0x45, 0x4e, 0x45, 0x57, 0x5f, 0x4b, 0x56, 0x10, 0x08, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x48, 0x4f,
	0x53, 0x54, 0x57, 0x52, 0x49, 0x54, 0x45, 0x52, 0x10, 0x06, 0x12, 0x0e, 0x0a, 0x0a, 0x44, 0x45,
	0x50, 0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x0a, 0x12, 0x0e, 0x0a, 0x0a, 0x41, 0x4e,
	0x59, 0x5f, 0x52, 0x45, 0x50, 0x4c, 0x49, 0x44, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x41, 0x4e,
	0x59, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x4e, 0x59, 0x5f,
	0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x10, 0x04, 0x12, 0x12, 0x0a, 0x0e, 0x41, 0x4e, 0x59,
	0x5f, 0x53, 0x55, 0x42, 0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x10, 0x09, 0x42, 0x27, 0x5a,
	0x25, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6c,
	0x69, 0x74, 0x2f, 0x67, 0x6f, 0x2d, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x2f, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_api_signing_proto_rawDescOnce sync.Once
	file_api_signing_proto_rawDescData = file_api_signing_proto_rawDesc
)

func file_api_signing_proto_rawDescGZIP() []byte {
	file_api_signing_proto_rawDescOnce.Do(func() {
		file_api_signing_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_signing_proto_rawDescData)
	})
	return file_api_signing_proto_rawDescData
}

var file_api_signing_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_api_signing_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_api_signing_proto_goTypes = []interface{}{
	(TokenVersion)(0),              // 0: api.TokenVersion
	(FlagClaim)(0),                 // 1: api.FlagClaim
	(*GovalSigningAuthority)(nil),  // 2: api.GovalSigningAuthority
	(*CertificateClaim)(nil),       // 3: api.CertificateClaim
	(*GovalCert)(nil),              // 4: api.GovalCert
	(*GovalToken)(nil),             // 5: api.GovalToken
	(*GovalReplIdentity)(nil),      // 6: api.GovalReplIdentity
	(*BuildInfo)(nil),              // 7: api.BuildInfo
	(*ReplRuntimeInteractive)(nil), // 8: api.ReplRuntimeInteractive
	(*ReplRuntimeDeployment)(nil),  // 9: api.ReplRuntimeDeployment
	(*timestamp.Timestamp)(nil),    // 10: google.protobuf.Timestamp
	(*ReplToken)(nil),              // 11: api.ReplToken
}
var file_api_signing_proto_depIdxs = []int32{
	0,  // 0: api.GovalSigningAuthority.version:type_name -> api.TokenVersion
	1,  // 1: api.CertificateClaim.flag:type_name -> api.FlagClaim
	10, // 2: api.GovalCert.iat:type_name -> google.protobuf.Timestamp
	10, // 3: api.GovalCert.exp:type_name -> google.protobuf.Timestamp
	3,  // 4: api.GovalCert.claims:type_name -> api.CertificateClaim
	10, // 5: api.GovalToken.iat:type_name -> google.protobuf.Timestamp
	10, // 6: api.GovalToken.exp:type_name -> google.protobuf.Timestamp
	11, // 7: api.GovalToken.repl_token:type_name -> api.ReplToken
	6,  // 8: api.GovalToken.repl_identity:type_name -> api.GovalReplIdentity
	7,  // 9: api.GovalReplIdentity.build_info:type_name -> api.BuildInfo
	8,  // 10: api.GovalReplIdentity.interactive:type_name -> api.ReplRuntimeInteractive
	9,  // 11: api.GovalReplIdentity.deployment:type_name -> api.ReplRuntimeDeployment
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_api_signing_proto_init() }
func file_api_signing_proto_init() {
	if File_api_signing_proto != nil {
		return
	}
	file_api_client_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_api_signing_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GovalSigningAuthority); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CertificateClaim); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GovalCert); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GovalToken); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GovalReplIdentity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BuildInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReplRuntimeInteractive); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_signing_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReplRuntimeDeployment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_api_signing_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*GovalSigningAuthority_KeyId)(nil),
		(*GovalSigningAuthority_SignedCert)(nil),
	}
	file_api_signing_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*CertificateClaim_Replid)(nil),
		(*CertificateClaim_User)(nil),
		(*CertificateClaim_Cluster)(nil),
		(*CertificateClaim_Subcluster)(nil),
		(*CertificateClaim_Flag)(nil),
	}
	file_api_signing_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*GovalToken_ReplToken)(nil),
		(*GovalToken_ReplIdentity)(nil),
	}
	file_api_signing_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*GovalReplIdentity_Interactive)(nil),
		(*GovalReplIdentity_Deployment)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_api_signing_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_signing_proto_goTypes,
		DependencyIndexes: file_api_signing_proto_depIdxs,
		EnumInfos:         file_api_signing_proto_enumTypes,
		MessageInfos:      file_api_signing_proto_msgTypes,
	}.Build()
	File_api_signing_proto = out.File
	file_api_signing_proto_rawDesc = nil
	file_api_signing_proto_goTypes = nil
	file_api_signing_proto_depIdxs = nil
}
