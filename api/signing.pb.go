// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/signing.proto

package api

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TokenVersion int32

const (
	// Body contains are bare ReplToken and must be decoded explicitly
	TokenVersion_BARE_REPL_TOKEN TokenVersion = 0
	// Body contains a GovalToken and can be interrogated about the type of its own
	// message
	TokenVersion_TYPE_AWARE_TOKEN TokenVersion = 1
)

var TokenVersion_name = map[int32]string{
	0: "BARE_REPL_TOKEN",
	1: "TYPE_AWARE_TOKEN",
}

var TokenVersion_value = map[string]int32{
	"BARE_REPL_TOKEN":  0,
	"TYPE_AWARE_TOKEN": 1,
}

func (x TokenVersion) String() string {
	return proto.EnumName(TokenVersion_name, int32(x))
}

func (TokenVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{0}
}

type FlagClaim int32

const (
	// Cert has the authority to sign ReplToken messages that can be validated
	// by goval
	FlagClaim_MINT_GOVAL_TOKEN FlagClaim = 0
	// Cert has the authority to sign additional intermediate certs. (The claims
	// on intermediate certs signed by this cert are still enforced.)
	FlagClaim_SIGN_INTERMEDIATE_CERT FlagClaim = 1
	// Cert has the authority to sign GovalToken messages that can prove identity.
	FlagClaim_IDENTITY FlagClaim = 5
	// Cert has the authority to sign ReplToken messages for any ReplID. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_REPLID FlagClaim = 2
	// Cert has the authority to sign ReplToken messages for any user. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_USER FlagClaim = 3
	// Cert has the authority to sign ReplToken messages for any cluster. If this
	// claim is not set, the cert will only be able to emit tokens only for the
	// list explicitly enumerated by the other claims. If that list is empty, the
	// cert has no ability to sign any tokens.
	FlagClaim_ANY_CLUSTER FlagClaim = 4
)

var FlagClaim_name = map[int32]string{
	0: "MINT_GOVAL_TOKEN",
	1: "SIGN_INTERMEDIATE_CERT",
	5: "IDENTITY",
	2: "ANY_REPLID",
	3: "ANY_USER",
	4: "ANY_CLUSTER",
}

var FlagClaim_value = map[string]int32{
	"MINT_GOVAL_TOKEN":       0,
	"SIGN_INTERMEDIATE_CERT": 1,
	"IDENTITY":               5,
	"ANY_REPLID":             2,
	"ANY_USER":               3,
	"ANY_CLUSTER":            4,
}

func (x FlagClaim) String() string {
	return proto.EnumName(FlagClaim_name, int32(x))
}

func (FlagClaim) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{1}
}

// GovalSigningAuthority is information about a goval token, that can be used to
// validate it. It is stored in the footer of the PASETO.
type GovalSigningAuthority struct {
	// Types that are valid to be assigned to Cert:
	//	*GovalSigningAuthority_KeyId
	//	*GovalSigningAuthority_SignedCert
	Cert isGovalSigningAuthority_Cert `protobuf_oneof:"cert"`
	// An enum detailing how the body of the PASETO this is a footer of should
	// be decoded
	Version TokenVersion `protobuf:"varint,3,opt,name=version,proto3,enum=api.TokenVersion" json:"version,omitempty"`
	// A string containing the issuer of a token. This is used to track who is
	// sending tokens with a particular key id, so that we can rotate safely.
	Issuer               string   `protobuf:"bytes,4,opt,name=issuer,proto3" json:"issuer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GovalSigningAuthority) Reset()         { *m = GovalSigningAuthority{} }
func (m *GovalSigningAuthority) String() string { return proto.CompactTextString(m) }
func (*GovalSigningAuthority) ProtoMessage()    {}
func (*GovalSigningAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{0}
}

func (m *GovalSigningAuthority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GovalSigningAuthority.Unmarshal(m, b)
}
func (m *GovalSigningAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GovalSigningAuthority.Marshal(b, m, deterministic)
}
func (m *GovalSigningAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovalSigningAuthority.Merge(m, src)
}
func (m *GovalSigningAuthority) XXX_Size() int {
	return xxx_messageInfo_GovalSigningAuthority.Size(m)
}
func (m *GovalSigningAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_GovalSigningAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_GovalSigningAuthority proto.InternalMessageInfo

type isGovalSigningAuthority_Cert interface {
	isGovalSigningAuthority_Cert()
}

type GovalSigningAuthority_KeyId struct {
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3,oneof"`
}

type GovalSigningAuthority_SignedCert struct {
	SignedCert string `protobuf:"bytes,2,opt,name=signed_cert,json=signedCert,proto3,oneof"`
}

func (*GovalSigningAuthority_KeyId) isGovalSigningAuthority_Cert() {}

func (*GovalSigningAuthority_SignedCert) isGovalSigningAuthority_Cert() {}

func (m *GovalSigningAuthority) GetCert() isGovalSigningAuthority_Cert {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *GovalSigningAuthority) GetKeyId() string {
	if x, ok := m.GetCert().(*GovalSigningAuthority_KeyId); ok {
		return x.KeyId
	}
	return ""
}

func (m *GovalSigningAuthority) GetSignedCert() string {
	if x, ok := m.GetCert().(*GovalSigningAuthority_SignedCert); ok {
		return x.SignedCert
	}
	return ""
}

func (m *GovalSigningAuthority) GetVersion() TokenVersion {
	if m != nil {
		return m.Version
	}
	return TokenVersion_BARE_REPL_TOKEN
}

func (m *GovalSigningAuthority) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GovalSigningAuthority) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GovalSigningAuthority_KeyId)(nil),
		(*GovalSigningAuthority_SignedCert)(nil),
	}
}

// Claims are actions that a cert is allowed to do. Claims can be repeated (e.g.
// to allow a cert to apply to multiple replids or users).
//
// Claims should be enforced on certificates by ensuring that certificates
// are signed by a certificate that has a superset of claims.
//
// When a cert is used to sign a message, it is the responsibility of the service
// validating the message to ensure that any requests in the message are backed
// up by claims in the certificate. Claims in a single certificate should be
// interpreted as a union (e.g. if replid and user is set, the token may apply
// to any repls owned by the user, or any repls in replid, regardless of the
// owner).
type CertificateClaim struct {
	// Types that are valid to be assigned to Claim:
	//	*CertificateClaim_Replid
	//	*CertificateClaim_User
	//	*CertificateClaim_Cluster
	//	*CertificateClaim_Flag
	Claim                isCertificateClaim_Claim `protobuf_oneof:"claim"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CertificateClaim) Reset()         { *m = CertificateClaim{} }
func (m *CertificateClaim) String() string { return proto.CompactTextString(m) }
func (*CertificateClaim) ProtoMessage()    {}
func (*CertificateClaim) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{1}
}

func (m *CertificateClaim) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateClaim.Unmarshal(m, b)
}
func (m *CertificateClaim) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateClaim.Marshal(b, m, deterministic)
}
func (m *CertificateClaim) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateClaim.Merge(m, src)
}
func (m *CertificateClaim) XXX_Size() int {
	return xxx_messageInfo_CertificateClaim.Size(m)
}
func (m *CertificateClaim) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateClaim.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateClaim proto.InternalMessageInfo

type isCertificateClaim_Claim interface {
	isCertificateClaim_Claim()
}

type CertificateClaim_Replid struct {
	Replid string `protobuf:"bytes,1,opt,name=replid,proto3,oneof"`
}

type CertificateClaim_User struct {
	User string `protobuf:"bytes,2,opt,name=user,proto3,oneof"`
}

type CertificateClaim_Cluster struct {
	Cluster string `protobuf:"bytes,4,opt,name=cluster,proto3,oneof"`
}

type CertificateClaim_Flag struct {
	Flag FlagClaim `protobuf:"varint,3,opt,name=flag,proto3,enum=api.FlagClaim,oneof"`
}

func (*CertificateClaim_Replid) isCertificateClaim_Claim() {}

func (*CertificateClaim_User) isCertificateClaim_Claim() {}

func (*CertificateClaim_Cluster) isCertificateClaim_Claim() {}

func (*CertificateClaim_Flag) isCertificateClaim_Claim() {}

func (m *CertificateClaim) GetClaim() isCertificateClaim_Claim {
	if m != nil {
		return m.Claim
	}
	return nil
}

func (m *CertificateClaim) GetReplid() string {
	if x, ok := m.GetClaim().(*CertificateClaim_Replid); ok {
		return x.Replid
	}
	return ""
}

func (m *CertificateClaim) GetUser() string {
	if x, ok := m.GetClaim().(*CertificateClaim_User); ok {
		return x.User
	}
	return ""
}

func (m *CertificateClaim) GetCluster() string {
	if x, ok := m.GetClaim().(*CertificateClaim_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (m *CertificateClaim) GetFlag() FlagClaim {
	if x, ok := m.GetClaim().(*CertificateClaim_Flag); ok {
		return x.Flag
	}
	return FlagClaim_MINT_GOVAL_TOKEN
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CertificateClaim) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CertificateClaim_Replid)(nil),
		(*CertificateClaim_User)(nil),
		(*CertificateClaim_Cluster)(nil),
		(*CertificateClaim_Flag)(nil),
	}
}

// GovalCert provides a mechanism of establishing a chain of trust without
// requiring a single private key to be duplciated to all services that send messages.
// The processes of generating intermediate certs is as follows:
// - A PASETO `v2.public` root keypair is generated and added to GSM with an
//   arbitrary key id.
// - The root public key id is encoded in a GovalSigningAuthority
// - An intermediate PASETO `v2.public` keypair is generated
// - The intermediate public key is encoded in a GovalCert, along with
//   information about the lifetime and claims of that cert.
// - The GovalCert is encoded in the body of a PASETO and signed with the root
//   private key. The root signing authority is inserted into the footer of the
//   PASETO to use for validation.
// - This signed PASETO is encoded in another GovalSigningAuthority and appended
//   as the footer of PASETOs signed by the intermediate private key.
// Additional intermediate certs can be generated and signed by private key and
// signing authority of the previous cert.
//
// When validating a chain of certs, the footer of each wrapped PASETO is
// recursed until reaching a root key id. The body of that PASETO is
// validated with the root public key. The body is decoded into a GovalCert,
// its lifetime is checked, and the public key is pulled out and used to validate
// the next PASETO, continuing back up the chain.
// At each step along the chain (except for the root), the claims of a certificate
// must be verified to be a subset of the claims of the certificate signing it.
type GovalCert struct {
	// Issue timestamp. Equivalent to JWT's "iat" (Issued At) claim.  Tokens with
	// no `iat` field will be treated as if they had been issed at the UNIX epoch
	// (1970-01-01T00:00:00Z).
	Iat *timestamp.Timestamp `protobuf:"bytes,1,opt,name=iat,proto3" json:"iat,omitempty"`
	// Expiration timestamp. Equivalent to JWT's "exp" (Expiration Time) Claim.
	// If unset, will default to one hour after `iat`.
	Exp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=exp,proto3" json:"exp,omitempty"`
	// A list of claims this cert can authorize
	Claims []*CertificateClaim `protobuf:"bytes,3,rep,name=claims,proto3" json:"claims,omitempty"`
	// The PASETO `v2.public` (Ed25519) public key authorized to sign requests in
	// this scope. Must be encoded in either PASERK SID or a PEM PUBLIC KEY
	// block.  (This key is usally generated in nodejs, and nodejs does not
	// provide an interface to get the raw key bytes)
	PublicKey            string   `protobuf:"bytes,4,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GovalCert) Reset()         { *m = GovalCert{} }
func (m *GovalCert) String() string { return proto.CompactTextString(m) }
func (*GovalCert) ProtoMessage()    {}
func (*GovalCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{2}
}

func (m *GovalCert) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GovalCert.Unmarshal(m, b)
}
func (m *GovalCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GovalCert.Marshal(b, m, deterministic)
}
func (m *GovalCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovalCert.Merge(m, src)
}
func (m *GovalCert) XXX_Size() int {
	return xxx_messageInfo_GovalCert.Size(m)
}
func (m *GovalCert) XXX_DiscardUnknown() {
	xxx_messageInfo_GovalCert.DiscardUnknown(m)
}

var xxx_messageInfo_GovalCert proto.InternalMessageInfo

func (m *GovalCert) GetIat() *timestamp.Timestamp {
	if m != nil {
		return m.Iat
	}
	return nil
}

func (m *GovalCert) GetExp() *timestamp.Timestamp {
	if m != nil {
		return m.Exp
	}
	return nil
}

func (m *GovalCert) GetClaims() []*CertificateClaim {
	if m != nil {
		return m.Claims
	}
	return nil
}

func (m *GovalCert) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

// A GovalToken should be the body of any PASETO we send
type GovalToken struct {
	// Issue timestamp. Equivalent to JWT's "iat" (Issued At) claim.  Tokens with
	// no `iat` field will be treated as if they had been issed at the UNIX epoch
	// (1970-01-01T00:00:00Z).
	Iat *timestamp.Timestamp `protobuf:"bytes,1,opt,name=iat,proto3" json:"iat,omitempty"`
	// Expiration timestamp. Equivalent to JWT's "exp" (Expiration Time) Claim.
	// If unset, will default to one hour after `iat`.
	Exp *timestamp.Timestamp `protobuf:"bytes,2,opt,name=exp,proto3" json:"exp,omitempty"`
	// Tokens are only allowed to act for a single repl, replid is the repl that
	// this token is authorized for. The validator must check that the replid of
	// this token agrees with the claims in any of the certs signing it.
	Replid string `protobuf:"bytes,3,opt,name=replid,proto3" json:"replid,omitempty"`
	// The token body, all future tokens should rely on the information in
	// GovalToken to establish basic validity, and should only add additional
	// fields. ReplToken has its own iat, exp, and replid for legacy reasons.
	//
	// Types that are valid to be assigned to Token:
	//	*GovalToken_ReplToken
	//	*GovalToken_ReplIdentity
	Token                isGovalToken_Token `protobuf_oneof:"Token"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GovalToken) Reset()         { *m = GovalToken{} }
func (m *GovalToken) String() string { return proto.CompactTextString(m) }
func (*GovalToken) ProtoMessage()    {}
func (*GovalToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{3}
}

func (m *GovalToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GovalToken.Unmarshal(m, b)
}
func (m *GovalToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GovalToken.Marshal(b, m, deterministic)
}
func (m *GovalToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovalToken.Merge(m, src)
}
func (m *GovalToken) XXX_Size() int {
	return xxx_messageInfo_GovalToken.Size(m)
}
func (m *GovalToken) XXX_DiscardUnknown() {
	xxx_messageInfo_GovalToken.DiscardUnknown(m)
}

var xxx_messageInfo_GovalToken proto.InternalMessageInfo

func (m *GovalToken) GetIat() *timestamp.Timestamp {
	if m != nil {
		return m.Iat
	}
	return nil
}

func (m *GovalToken) GetExp() *timestamp.Timestamp {
	if m != nil {
		return m.Exp
	}
	return nil
}

func (m *GovalToken) GetReplid() string {
	if m != nil {
		return m.Replid
	}
	return ""
}

type isGovalToken_Token interface {
	isGovalToken_Token()
}

type GovalToken_ReplToken struct {
	ReplToken *ReplToken `protobuf:"bytes,4,opt,name=repl_token,json=replToken,proto3,oneof"`
}

type GovalToken_ReplIdentity struct {
	ReplIdentity *GovalReplIdentity `protobuf:"bytes,5,opt,name=repl_identity,json=replIdentity,proto3,oneof"`
}

func (*GovalToken_ReplToken) isGovalToken_Token() {}

func (*GovalToken_ReplIdentity) isGovalToken_Token() {}

func (m *GovalToken) GetToken() isGovalToken_Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *GovalToken) GetReplToken() *ReplToken {
	if x, ok := m.GetToken().(*GovalToken_ReplToken); ok {
		return x.ReplToken
	}
	return nil
}

func (m *GovalToken) GetReplIdentity() *GovalReplIdentity {
	if x, ok := m.GetToken().(*GovalToken_ReplIdentity); ok {
		return x.ReplIdentity
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GovalToken) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GovalToken_ReplToken)(nil),
		(*GovalToken_ReplIdentity)(nil),
	}
}

// A GovalReplIdentity is used in identity PASETO tokens which are used for
// authentication between repls.
type GovalReplIdentity struct {
	// This identity has this Repl ID
	Replid string `protobuf:"bytes,1,opt,name=replid,proto3" json:"replid,omitempty"`
	// This identity is in the context of this user
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// This repl has this slug
	Slug string `protobuf:"bytes,3,opt,name=slug,proto3" json:"slug,omitempty"`
	// If set, this token can only be consumed by this a Repl with this Repl ID.
	// Equivalent to JWT's "aud" (Audience) claim.
	Aud string `protobuf:"bytes,4,opt,name=aud,proto3" json:"aud,omitempty"`
	// If set, this identity is for an ephemeral repl (e.g. a guest fork).
	Ephemeral            bool     `protobuf:"varint,5,opt,name=ephemeral,proto3" json:"ephemeral,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GovalReplIdentity) Reset()         { *m = GovalReplIdentity{} }
func (m *GovalReplIdentity) String() string { return proto.CompactTextString(m) }
func (*GovalReplIdentity) ProtoMessage()    {}
func (*GovalReplIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3f3ccd3fca57e42, []int{4}
}

func (m *GovalReplIdentity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GovalReplIdentity.Unmarshal(m, b)
}
func (m *GovalReplIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GovalReplIdentity.Marshal(b, m, deterministic)
}
func (m *GovalReplIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovalReplIdentity.Merge(m, src)
}
func (m *GovalReplIdentity) XXX_Size() int {
	return xxx_messageInfo_GovalReplIdentity.Size(m)
}
func (m *GovalReplIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_GovalReplIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_GovalReplIdentity proto.InternalMessageInfo

func (m *GovalReplIdentity) GetReplid() string {
	if m != nil {
		return m.Replid
	}
	return ""
}

func (m *GovalReplIdentity) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *GovalReplIdentity) GetSlug() string {
	if m != nil {
		return m.Slug
	}
	return ""
}

func (m *GovalReplIdentity) GetAud() string {
	if m != nil {
		return m.Aud
	}
	return ""
}

func (m *GovalReplIdentity) GetEphemeral() bool {
	if m != nil {
		return m.Ephemeral
	}
	return false
}

func init() {
	proto.RegisterEnum("api.TokenVersion", TokenVersion_name, TokenVersion_value)
	proto.RegisterEnum("api.FlagClaim", FlagClaim_name, FlagClaim_value)
	proto.RegisterType((*GovalSigningAuthority)(nil), "api.GovalSigningAuthority")
	proto.RegisterType((*CertificateClaim)(nil), "api.CertificateClaim")
	proto.RegisterType((*GovalCert)(nil), "api.GovalCert")
	proto.RegisterType((*GovalToken)(nil), "api.GovalToken")
	proto.RegisterType((*GovalReplIdentity)(nil), "api.GovalReplIdentity")
}

func init() { proto.RegisterFile("api/signing.proto", fileDescriptor_a3f3ccd3fca57e42) }

var fileDescriptor_a3f3ccd3fca57e42 = []byte{
	// 653 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x53, 0x41, 0x4f, 0xdb, 0x4c,
	0x10, 0x8d, 0x71, 0x12, 0xc8, 0x84, 0x0f, 0xcc, 0x7e, 0x90, 0x5a, 0x51, 0xa5, 0xd2, 0xa8, 0x55,
	0x11, 0x2d, 0xb6, 0x44, 0x4f, 0x3d, 0xf4, 0x90, 0x04, 0x97, 0x58, 0x40, 0x40, 0x1b, 0x43, 0x45,
	0x2f, 0xd6, 0xc6, 0x59, 0xcc, 0x0a, 0x27, 0xb6, 0xec, 0x35, 0x22, 0xbd, 0xf6, 0xdc, 0xff, 0xd0,
	0x1f, 0xd1, 0x3f, 0xd7, 0x5b, 0xb5, 0xeb, 0x35, 0x49, 0xdb, 0x43, 0x4f, 0xbd, 0x79, 0x66, 0xde,
	0xcc, 0xbc, 0x7d, 0x6f, 0x0c, 0x5b, 0x24, 0x61, 0x76, 0xc6, 0xc2, 0x19, 0x9b, 0x85, 0x56, 0x92,
	0xc6, 0x3c, 0x46, 0x3a, 0x49, 0x58, 0xfb, 0x59, 0x18, 0xc7, 0x61, 0x44, 0x6d, 0x99, 0x1a, 0xe7,
	0x37, 0x36, 0x67, 0x53, 0x9a, 0x71, 0x32, 0x4d, 0x0a, 0x54, 0xdb, 0x10, 0x8d, 0x41, 0xc4, 0xe8,
	0x8c, 0x17, 0x99, 0xce, 0x37, 0x0d, 0x76, 0x8e, 0xe3, 0x7b, 0x12, 0x8d, 0x8a, 0x71, 0xdd, 0x9c,
	0xdf, 0xc6, 0x29, 0xe3, 0x73, 0xf4, 0x04, 0xea, 0x77, 0x74, 0xee, 0xb3, 0x89, 0xa9, 0xed, 0x6a,
	0x7b, 0x8d, 0x41, 0x05, 0xd7, 0xee, 0xe8, 0xdc, 0x9d, 0xa0, 0xe7, 0xd0, 0x14, 0xbb, 0xe9, 0xc4,
	0x0f, 0x68, 0xca, 0xcd, 0x15, 0x55, 0x85, 0x22, 0xd9, 0xa7, 0x29, 0x47, 0xaf, 0x61, 0xf5, 0x9e,
	0xa6, 0x19, 0x8b, 0x67, 0xa6, 0xbe, 0xab, 0xed, 0x6d, 0x1c, 0x6e, 0x59, 0x24, 0x61, 0x96, 0x17,
	0xdf, 0xd1, 0xd9, 0x55, 0x51, 0xc0, 0x25, 0x02, 0xb5, 0xa0, 0xce, 0xb2, 0x2c, 0xa7, 0xa9, 0x59,
	0x15, 0xa3, 0xb0, 0x8a, 0x7a, 0x75, 0xa8, 0x8a, 0x05, 0x9d, 0xaf, 0x1a, 0x18, 0x62, 0x2a, 0xbb,
	0x61, 0x01, 0xe1, 0xb4, 0x1f, 0x11, 0x36, 0x45, 0x26, 0xd4, 0x53, 0x9a, 0x44, 0x4b, 0xec, 0x54,
	0x8c, 0xb6, 0xa1, 0x9a, 0x67, 0x34, 0x7d, 0xe4, 0x25, 0x23, 0xd4, 0x86, 0xd5, 0x20, 0xca, 0x33,
	0x5e, 0x6e, 0x19, 0x54, 0x70, 0x99, 0x40, 0x2f, 0xa0, 0x7a, 0x13, 0x91, 0x50, 0x51, 0xdd, 0x90,
	0x54, 0x3f, 0x44, 0x24, 0x94, 0x9b, 0xc4, 0x04, 0x51, 0xed, 0xad, 0x42, 0x2d, 0x10, 0x89, 0xce,
	0x77, 0x0d, 0x1a, 0x52, 0x32, 0xf9, 0xd4, 0x37, 0xa0, 0x33, 0xc2, 0x25, 0x8b, 0xe6, 0x61, 0xdb,
	0x2a, 0x1c, 0xb0, 0x4a, 0x07, 0x2c, 0xaf, 0x74, 0x00, 0x0b, 0x98, 0x40, 0xd3, 0x87, 0x44, 0x72,
	0xfb, 0x0b, 0x9a, 0x3e, 0x24, 0xe8, 0x00, 0xea, 0x72, 0x65, 0x66, 0xea, 0xbb, 0xfa, 0x5e, 0xf3,
	0x70, 0x47, 0x52, 0xfb, 0x5d, 0x0b, 0xac, 0x40, 0xe8, 0x29, 0x34, 0x92, 0x7c, 0x1c, 0xb1, 0xe0,
	0x84, 0xce, 0x95, 0x96, 0x8b, 0x44, 0xe7, 0x87, 0x06, 0x20, 0x69, 0x4b, 0x17, 0xfe, 0x29, 0xef,
	0xd6, 0xa3, 0x39, 0x7a, 0xe1, 0xa8, 0xb2, 0xc6, 0x06, 0x10, 0x5f, 0x3e, 0x17, 0x0c, 0x24, 0xc3,
	0xa6, 0x92, 0x1b, 0xd3, 0xa4, 0xe0, 0x35, 0xa8, 0xe0, 0x46, 0x5a, 0x06, 0xe8, 0x3d, 0xfc, 0x27,
	0x1b, 0xd8, 0x84, 0xce, 0x38, 0xe3, 0x73, 0xb3, 0x26, 0x7b, 0x5a, 0xb2, 0x47, 0x3e, 0x46, 0x34,
	0xba, 0xaa, 0x3a, 0xa8, 0xe0, 0xf5, 0x74, 0x29, 0x16, 0x96, 0xc9, 0x39, 0x9d, 0x2f, 0x1a, 0x6c,
	0xfd, 0x01, 0x5f, 0xa2, 0xa9, 0xfd, 0x42, 0x13, 0x2d, 0x5f, 0x90, 0xba, 0x1f, 0x04, 0xd5, 0x2c,
	0xca, 0x43, 0xf5, 0x20, 0xf9, 0x8d, 0x0c, 0xd0, 0x49, 0x3e, 0x51, 0x4a, 0x8b, 0x4f, 0xe1, 0x00,
	0x4d, 0x6e, 0xe9, 0x94, 0xa6, 0x24, 0x92, 0x5c, 0xd7, 0xf0, 0x22, 0xb1, 0xff, 0x0e, 0xd6, 0x97,
	0xff, 0x00, 0xf4, 0x3f, 0x6c, 0xf6, 0xba, 0xd8, 0xf1, 0xb1, 0x73, 0x71, 0xea, 0x7b, 0xe7, 0x27,
	0xce, 0xd0, 0xa8, 0xa0, 0x6d, 0x30, 0xbc, 0xeb, 0x0b, 0xc7, 0xef, 0x7e, 0x14, 0xa5, 0x22, 0xab,
	0xed, 0x7f, 0x86, 0xc6, 0xe3, 0x45, 0x0a, 0xc8, 0x99, 0x3b, 0xf4, 0xfc, 0xe3, 0xf3, 0xab, 0xee,
	0xa2, 0xb1, 0x0d, 0xad, 0x91, 0x7b, 0x3c, 0xf4, 0xdd, 0xa1, 0xe7, 0xe0, 0x33, 0xe7, 0xc8, 0xed,
	0x7a, 0x8e, 0xdf, 0x77, 0xb0, 0x67, 0x68, 0x68, 0x1d, 0xd6, 0xdc, 0x23, 0x67, 0xe8, 0xb9, 0xde,
	0xb5, 0x51, 0x43, 0x1b, 0x00, 0xdd, 0xe1, 0xb5, 0x5c, 0xeb, 0x1e, 0x19, 0x2b, 0xa2, 0x2a, 0xe2,
	0xcb, 0x91, 0x83, 0x0d, 0x1d, 0x6d, 0x42, 0x53, 0x44, 0xfd, 0xd3, 0xcb, 0x91, 0xe7, 0x60, 0xa3,
	0xda, 0x7b, 0xf5, 0xe9, 0x65, 0xc8, 0xf8, 0x6d, 0x3e, 0xb6, 0x82, 0x78, 0x6a, 0x4b, 0x8d, 0xb8,
	0x1d, 0xc6, 0x07, 0x85, 0x5a, 0x85, 0x96, 0x36, 0x49, 0xd8, 0xb8, 0x2e, 0xef, 0xe1, 0xed, 0xcf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x06, 0x2a, 0x8c, 0x54, 0x9f, 0x04, 0x00, 0x00,
}
